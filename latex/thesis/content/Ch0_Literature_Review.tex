\chapter{\rm\bfseries Related Literature}
\label{ch:litreview}

Translating concepts into computer programs demands a high degree of precision, as computers have strict criteria for admitting valid programs. These constraints help eliminate meaningless programs and reduce runtime errors, but can be cumbersome to debug. During the process of programming, these constraints are inevitably violated, requiring typically manual repair. Automated repair attempts to suggest potential repairs from which the author may choose. This subject has been closely investigated in programming language research and treated in a number of existing literature reviews~\cite{monperrus2018living, le2021automatic}. We direct our attention primarily towards syntax repair, which attempts to repair parsing errors, the earliest stage in program analysis.

\section{Syntax Repair}

Various strategies have been proposed to handle syntactic program errors, which have been a longstanding open problem since the advent of context-free languages. In 1972, Aho and Peterson~\cite{aho1972minimum} introduce an algorithm that returns a syntactically valid sequence whose distance from the original sequence is minimal. Their method guarantees that a valid repair will be found, but only selects one and does not produce every valid repair within the same distance.

While algorithmically elegant, this approach is problematic, because source code has both formal and natural characteristics. A pragmatic solution must not only suggest valid repairs, but also generate suggestions a human being is likely to write in practice. To model the natural distribution of valid programs, researchers have borrowed techniques from natural language processing to generate natural repairs.

Recent work Yasunaga et al.~\cite{yasunaga2021break} and Sakkas et al.~\cite{sakkas2022seq2parse} use language models to sample probable fixes, but do not sample from the space of all valid repairs, and have difficulty with inference scaling, where additional test time samples are not . Furthermore, the generated samples are not all syntactically valid.

Our work addresses all these concerns. We try to generate all valid programs and prioritize them by naturalness, while ensuring that the latency and response time is minimal. In other words, we target soundness, completeness, naturalness and latency.


\clearpage