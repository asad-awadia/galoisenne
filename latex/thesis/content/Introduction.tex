\chapter*{\rm\bfseries Introduction}
\label{ch:introduction}

\epigraph{Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out?}{--Charles Babbage (1791--1871)}

%\mcgillguidelines Clearly state the rationale and objectives of the research.

Computer programs are instructions for performing a chore that humans would rather avoid doing ourselves. In order to persuade the computer to do them for us, we must communicate our intention in a way that is plain and unambiguous. Programming languages are protocols for this dialogue. Every program is written in a language that was designed to facilitate the exchange of information between programmers and computers.

%By observing programmers, one can learn a great deal about how this dialogue unfolds.
Programs are seldom written from left-to-right in one go. During the course of writing a program, the programmer often revisits and revises code as they write, sharing additional information and receiving feedback. Often, during this process, the programmer makes a mistake, causing the program to behave in an unexpected manner. This mistake can be as simple as a typographic or syntactic error, or a more subtle runtime error.

To intercept these errors, programming language designers have adopted a convention for specifying valid programs, called a grammar, which serves two essential purposes. The first is to reject ill-formed programs, and the second is to transform the sequence into a treelike intermediate representation that can be handled by a compiler. We will focus on the first case.

When a program enters an invalid state, a series of unfortunate events occur. The compiler halts, and an error message is raised. To rectify this situation, the programmer must pause their work, plan a fix, apply it, then try to remember what they were doing beforehand. The cognitive overhead of this simple but repetitive chore can be tiresome. To make matters worse, the error message may be unhelpful or challenging to diagnose.

Program repair attempts to address this problem by inferring the author's intent from an approximate solution. We can think of this as playing a kind of language game. Given an invalid piece of source code for some programming language, the objective of this game is to modify the code to satisfy the language specification. The game is won when the proposed solution is both valid and the author is satisfied with the result. We want to play this game as efficiently as possible, with as little human feedback as possible.

%Various prorgram repair tools have been developed to automatically fix common programming errors. These tools can be broadly classified into two categories: static and dynamic. Static tools analyze the program's source code to infer the programmer's intent, while dynamic tools observe runtime behavior to diagnose the error. Both approaches have their strengths and weaknesses, but share a common goal: to anticipate the programmer's intent and modify the program to satisfy both the compiler and author simultaneously.

Our goal in this thesis is to introduce a theory of program repair. Broadly, our approach is to repair faulty programs by combining probabilistic language models with exact combinatorial methods. We do so by reformulating the problem of program repair in the parlance of formal language theory. In addition to being a natural fit for syntax repair, this also allows us to encode and compose static analyses as grammatical specifications.

Program repair is a highly underdetermined problem, meaning that the validity constraints do not uniquely determine a solution. A proper theory of program repair must be able to resolve this ambiguity to infer the user's intent from an incomplete specification, and incrementally refine its guess as more information becomes available from the user.

This theory we propose has a number of desirable properties. It is highly compositional, meaning that users can manipulate constraints on programs while retaining the algebraic closure properties, such as union, intersection, and differentiation. It is well-suited for probabilistic reasoning, meaning we can use any probabilistic model of language to guide the repair process. It is also amenable to incremental repair, meaning that we can repair programs in a streaming fashion, while the user is typing.